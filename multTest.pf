#DEFINE mod mm
@test
subroutine SimpleTest()
  use pfunit_mod
  use mod
  real (kind = 8) :: mtx1(1,1), mtx2(1,1), mtx3(1,1)
  integer(kind = 4) :: ret
  mtx1(1,1) = 5
  mtx2(1,1) = 3
  call mult(mtx1, mtx2, mtx3, ret)
  @assertEqual(15, mtx3(1,1))
end

@test
subroutine LongTest()
  use pfunit_mod
  use mod
  real (kind = 8) :: mtx1(1,10000), mtx2(10000,1), mtx3(1,1)
  integer(kind = 4) :: ret, i
  do i = 1, 10000
     mtx1(1,i) = 1
     mtx2(i,1) = 1
  end do

  call mult(mtx1, mtx2, mtx3, ret)
  @assertEqual(10000, mtx3(1,1))
end

@test
subroutine LushTest()
 use pfunit_mod
 use mod
 real (kind = 8) :: mtx1(1000,1), mtx2(1, 1000), mtx3(1000,1000), mtxres(1000, 1000)
 integer(kind = 4) :: ret, i, j
 do i = 1, 1000
    mtx2(1,i) = 1
    mtx1(i,1) = 1
    do j = 1, 1000
       mtxres(i,j) = 1;
    end do
 end do

 call mult(mtx1, mtx2, mtx3, ret)
 @assertEqual(mtxres, mtx3)
end

@test
subroutine ElephantTest()
 use pfunit_mod
 use mod
 real (kind = 8) :: mtx1(1000,500), mtx2(500, 700), mtx3(1000,700), mtxres(1000, 700)
 integer(kind = 4) :: ret, i, j
 do i = 1, 1000
    do j = 1, 500
       mtx1(i,j) = 1;
    end do
 end do
 do i = 1, 500
   do j = 1, 700
     mtx2(i,j) = 1;
   end do
 end do
 do i = 1, 1000
   do j = 1, 700
     mtxres(i,j) = 500;
   end do
 end do

 call mult(mtx1, mtx2, mtx3, ret)
 @assertEqual(mtxres, mtx3)
end

@test
subroutine NothingSpecialTest()
 use pfunit_mod
 use mod
 real (kind = 8) :: mtx1(3,5), mtx2(5,4), mtx3(3,4), mtxres(3, 4)
 integer(kind = 4) :: ret, i, j
 mtx1 = reshape((/ 1, 2, 4, 6, 8, 1, 6, 3, 6, 3, 6, 4, 8, 4, 4 /), (/3,5/))
 mtx2 = reshape((/ 1, 2, 4, 6, 8, 1, 6, 3, 6, 3, 6, 4, 8, 4, 4, 6, 7, 8, 5, 4/), (/5,4/))
 mtxres= reshape((/119, 98, 86, 97, 107, 64, 122, 108, 108, 143, 138, 115/), (/3,4/))
 ! I do consider line above as the most difficult task in a whole project

 call mult(mtx1, mtx2, mtx3, ret)
 @assertEqual(mtxres, mtx3)
end

@test
subroutine EvilTest()
 use pfunit_mod
 use mod
 real (kind = 8) :: mtx1(3,45), mtx2(78,23), mtx3(3,78)
 integer(kind = 4) :: ret

 call mult(mtx1, mtx2, mtx3, ret)
 @assertEqual(ret, 1.d0)
end
